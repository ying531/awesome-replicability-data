}
)$par # Maximum conditional likelihood
})
if (length(estimate >1)){
names(estimate) = vars
}else{
estimate = c(estimate,0)
names(estimate) = c(vars, "placeholder")
}
names(estimate) = vars
bounds$estimate = as.numeric(decomp[components])
bounds
bounds$estimate[which(bounds$low!=-Inf)] = sapply(
X = components[which(bounds$low!=-Inf)],
FUN = function(comp) {
if (comp == "Observed") {
return(observed)
} else if (comp == "Residual") {
return(as.numeric(2*estimate["Observed"] - sum(estimate)))
} else {
return(estimate[[comp]])
}
}
)
bounds
# Compute the estimate of sampling variability
bounds = rbind(bounds, observed - c(bounds["Observed", "high"], bounds["Observed", "low"], estimate["Observed"]))
bounds
observed
# Compute the estimate of sampling variability
bounds = rbind(bounds, observed - c(bounds["Observed", "high"], bounds["Observed", "low"], estimate["Observed"]))
bounds
c(bounds["Observed", "high"], bounds["Observed", "low"], estimate["Observed"])
# Compute the estimate of sampling variability
bounds = rbind(bounds, observed - c(bounds["Observed", "high"], bounds["Observed", "low"], bounds$estimate["Observed"]))
bounds
bounds = lapply(
X = components,
FUN = function(v) { vars = c(v, "Selected"); selective_ci(x[vars], S[vars, vars], threshold, alpha)}
) %>% bind_rows()
rownames(bounds) = components
# Compute selection-adjusted point estimates for the non-residual components
vars = setdiff(components[which(bounds$low != -Inf)], "Residual")
SX = S[vars, vars]
SXY = S[vars, "Selected"]
Omega = solve(SX)
beta = as.numeric(Omega %*% SXY)
sigma = as.numeric(sqrt(t(beta) %*% SX %*% beta))
R = as.numeric(x["Selected"] - sum(beta*x[vars]))
suppressWarnings({
estimate = optim(
par = as.numeric(unlist((bounds["high"] - bounds["low"])/2))[setdiff(which(bounds$low!=-Inf), length(components))], # Midpoint initialization
fn = function(par) {
0.5*t(as.numeric(x[vars]-par)) %*% Omega %*% as.numeric(x[vars]-par) +
truncprob(mean = sum(par*beta), sd = sigma, R = R, threshold = threshold, log.prob = T)
}
)$par # Maximum conditional likelihood
})
if (length(estimate >1)){
names(estimate) = vars
}else{
estimate = c(estimate,0)
names(estimate) = c(vars, "placeholder")
}
names(estimate) = vars
bounds$estimate = as.numeric(decomp[components])
bounds
bounds$estimate[which(bounds$low!=-Inf)] = sapply(
X = components[which(bounds$low!=-Inf)],
FUN = function(comp) {
if (comp == "Observed") {
return(observed)
} else if (comp == "Residual") {
return(as.numeric(2*estimate["Observed"] - sum(estimate)))
} else {
return(estimate[[comp]])
}
}
)
bounds
# Compute the estimate of sampling variability
bounds = rbind(bounds, observed - c(bounds["Observed", "high"], bounds["Observed", "low"], bounds$estimate["Observed"]))
bounds
observed
c(bounds["Observed", "high"], bounds["Observed", "low"], bounds$estimate["Observed"])
bounds$estimate
estimate
bounds = bounds[1:3,]
# Compute the estimate of sampling variability
bounds = rbind(bounds, observed - c(bounds["Observed", "high"], bounds["Observed", "low"], bounds$estimate[1]))
bounds
# Return results
bounds$component0 = c(components, "Sampling")
clean_names = data.frame(
component0 = c("Observed", "Covariates", "Mediators", "Residual", "Sampling"),
component = c("Observed discrepancy", "+ Covariate shift", "+ Mediation shift", "+ Residual", "= Sampling variability")
)
bounds = left_join(data.frame(bounds), clean_names, by = c("component0")) %>% select(-component0)
bounds
bounds
bounds = lapply(
X = components,
FUN = function(v) { vars = c(v, "Selected"); selective_ci(x[vars], S[vars, vars], threshold, alpha)}
) %>% bind_rows()
bounds
rownames(bounds) = components
bounds
# Compute selection-adjusted point estimates for the non-residual components
vars = setdiff(components[which(bounds$low != -Inf)], "Residual")
SX = S[vars, vars]
SXY = S[vars, "Selected"]
Omega = solve(SX)
beta = as.numeric(Omega %*% SXY)
sigma = as.numeric(sqrt(t(beta) %*% SX %*% beta))
R = as.numeric(x["Selected"] - sum(beta*x[vars]))
if (length(estimate >1)){
names(estimate) = vars
}else{
estimate = c(estimate,0)
names(estimate) = c(vars, "placeholder")
}
estimate
names(estimate) = vars
bounds$estimate = as.numeric(decomp[components])
bounds
bounds$estimate[which(bounds$low!=-Inf)] = sapply(
X = components[which(bounds$low!=-Inf)],
FUN = function(comp) {
if (comp == "Observed") {
return(observed)
} else if (comp == "Residual") {
return(as.numeric(2*estimate["Observed"] - sum(estimate)))
} else {
return(estimate[[comp]])
}
}
)
bounds
selective_decomposition = function(decomp, Sigma, threshold, alpha=0.1) {
# Selective confidence intervals and conditional MLEs
x = decomp#$decomp
S = Sigma#$Sigma
observed = x[["Observed"]]
# Compute selection-adjusted confidence intervals for each component
components = setdiff(names(x), "Selected")
bounds = lapply(
X = components,
FUN = function(v) { vars = c(v, "Selected"); selective_ci(x[vars], S[vars, vars], threshold, alpha)}
) %>% bind_rows()
rownames(bounds) = components
# Compute selection-adjusted point estimates for the non-residual components
vars = setdiff(components[which(bounds$low != -Inf)], "Residual")
SX = S[vars, vars]
SXY = S[vars, "Selected"]
Omega = solve(SX)
beta = as.numeric(Omega %*% SXY)
sigma = as.numeric(sqrt(t(beta) %*% SX %*% beta))
R = as.numeric(x["Selected"] - sum(beta*x[vars]))
suppressWarnings({
estimate = optim(
par = as.numeric(unlist((bounds["high"] - bounds["low"])/2))[setdiff(which(bounds$low!=-Inf), length(components))], # Midpoint initialization
fn = function(par) {
0.5*t(as.numeric(x[vars]-par)) %*% Omega %*% as.numeric(x[vars]-par) +
truncprob(mean = sum(par*beta), sd = sigma, R = R, threshold = threshold, log.prob = T)
}
)$par # Maximum conditional likelihood
})
if (length(estimate >1)){
names(estimate) = vars
}else{
estimate = c(estimate,0)
names(estimate) = c(vars, "placeholder")
}
names(estimate) = vars
bounds$estimate = as.numeric(decomp[components])
bounds$estimate[which(bounds$low!=-Inf)] = sapply(
X = components[which(bounds$low!=-Inf)],
FUN = function(comp) {
if (comp == "Observed") {
return(observed)
} else if (comp == "Residual") {
return(as.numeric(2*estimate["Observed"] - sum(estimate)))
} else {
return(estimate[[comp]])
}
}
)
# Compute the estimate of sampling variability
if (bounds$low[1] != -Inf){
bounds = rbind(bounds, observed - c(bounds["Observed", "high"], bounds["Observed", "low"], estimate["Observed"]))
}else{
bounds = rbind(bounds, observed - c(bounds["Observed", "high"], bounds["Observed", "low"], 0))
}
# Return results
bounds$component0 = c(components, "Sampling")
clean_names = data.frame(
component0 = c("Observed", "Covariates", "Mediators", "Residual", "Sampling"),
component = c("Observed discrepancy", "+ Covariate shift", "+ Mediation shift", "+ Residual", "= Sampling variability")
)
bounds = left_join(data.frame(bounds), clean_names, by = c("component0")) %>% select(-component0)
bounds$low[is.na(bounds$low)] = -Inf
bounds$high[is.na(bounds$high)] = Inf
return(bounds)
}
queue_result = run_diagnosis(org.dat.lab,
rep.dat.uwm,
analysis_formula = "median_speed ~ structure + gender + bornafter1990 + managerial",
treatment_variable = "structure",
covariates = c("gender", "bornafter1990", "managerial"),
verbose = FALSE,
pub_pvalue_threshold = 0.1)
cat(queue_result$sel.message)
queue.plt = queue_result$plot + ggtitle("Decomposition plot") + theme(title = element_text(size=18))
queue.plt
queue.plt
print(queue_result$table)
print(queue_result$sel.table)
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(ebal)
library(progress)
library(ggplot2)
library(lmtest)
library(sandwich)
library(repDiagnosis)
library(ggpubr)
library(ggtext)
queue.plt = queue_result$plot + ggtitle("Decomposition plot", hjust=-0.5) +
theme(title = element_text(size=18))
data(emdr_misinfo)
emdr_results = run_diagnosis(org_df = org.dat,
rep_df = rep.dat,
analysis_formula = "totalcorrect ~ condition",
treatment_variable = "condition",
covariate_formula = "~ age + gender + prevividness + preemotionality",
mediation_formula = "~  (age + gender + prevividness + preemotionality + postvividness + postemotionality)*condition",
verbose = FALSE)
# Decomposition plot
emdr_results$plot
# Decomposition plot after adjusting for publication bias
emdr_results$sel.plot
# Decomposition summary table
print(emdr_results$table)
# Decomposition summary table after adjusting for publication bias
print(emdr_results$sel.table)
# Decomposition summary table
cat(clean_results_2$table)
org.dat = read.csv("./host_data_paired/covid_study/original_clean.csv")
org.dat = read.csv("./host_data_paired/covid_study/original_clean.csv")
rep.dat = read.csv("./host_data_paired/covid_study/replication_clean.csv")
sum(org.dat$gender)
sum((org.dat %>% group_by(id) %>% slice(1))$gender)
sum(rep.dat$gender)
sum((rep.dat %>% group_by(id) %>% slice(1))$gender)
sum(1-(rep.dat %>% group_by(id) %>% slice(1))$gender)
org.dat = read.csv("./host_data_paired/covid_study/original_clean.csv")
org.dat = read.csv("./host_data_paired/covid_study/original_clean.csv")
rep.dat = read.csv("./host_data_paired/covid_study/replication_clean.csv")
sum(1-(rep.dat %>% group_by(id) %>% slice(1))$gender)
org.dat = read.csv("./host_data_paired/covid_study/original_clean.csv")
covid_result = run_diagnosis(org_df = org.dat,
rep_df = rep.dat,
analysis_formula = "rating ~ treatment + real + realxtreatment",
treatment_variable = "treatment",
focal_variable = "realxtreatment", # focal variable
covariate_formula = "~(age+gender+sciknow+mms+crt_acc)*treatment",
mediation_formula = NULL,
cluster_id = "id",
selection_variable = "realxtreatment",
alpha = 0.1,
verbose = FALSE,
if_selective = TRUE,
pub_pvalue_threshold = 0.05
)
org.dat
colnames(org.dat)
colnames(rep.dat)
org.dat = read.csv("./host_data_paired/covid_study/original_clean.csv")
covid_result = run_diagnosis(org_df = org.dat,
rep_df = rep.dat,
analysis_formula = "rating ~ treatment + real + realxtreatment",
treatment_variable = "treatment",
focal_variable = "realxtreatment", # focal variable
covariate_formula = "~(age+gender+sciknow+mms+crt_acc)*treatment",
mediation_formula = NULL,
cluster_id = "id",
selection_variable = "realxtreatment",
alpha = 0.1,
verbose = FALSE,
if_selective = TRUE,
pub_pvalue_threshold = 0.05
)
org_df = org.dat
rep_df = rep.dat
analysis_formula = "rating ~ treatment + real + realxtreatment"
treatment_variable = "treatment"
focal_variable = "realxtreatment"
covariate_formula = "~(age+gender+sciknow+mms+crt_acc)*treatment"
mediation_formula = NULL
"~ (demrep + gender + age + I(age^2) + sciknow + I(sciknow^2) + mms + I(mms^2) + crt_acc + I(crt_acc^2))*treatment"
covariate_formula = "~ (demrep + gender + age + I(age^2) + sciknow + I(sciknow^2) + mms + I(mms^2) + crt_acc + I(crt_acc^2))*treatment"
mediation_formula = NULL
cluster_id = "id"
selection_variable = "realxtreatment"
pub_pvalue_threshold = 0.05
covariates=NULL
mediators=NULL
df1 = data.frame(org_df)
df2 = data.frame(rep_df)
# if covariate formula is not provided, check whether the covariates argument is meaningful
# otherwise just use the covariate formula
if (is.null(covariate_formula)){
if (length(covariates) > 0){
for (i.par in 1:length(covariates)){
if (!is.na(suppressWarnings(as.integer(covariates[i.par])))){
covariates[i.par] = colnames(org_df)[as.integer(covariates[i.par])]
}
}
# if (is.null(treatment_variable)){
#   stop("Please provide the treatment variable argument!")
# }
covariate_formula = paste("~(", paste(covariates, collapse = "+"), ") *", treatment_variable)
}
}
# extract covariates and check whether it behaves normally
if (!is.null(covariate_formula)){
X1 = tryCatch({model.matrix(formula(covariate_formula), data=org_df)},
error = function(e) { return(NA) })
X2 = tryCatch({model.matrix(formula(covariate_formula), data=rep_df)},
error = function(e) { return(NA) })
if (is.na(X1) || is.na(X2)){ # any of the data fails to be extracted
stop("Covariate input does not work! \n")
}else{# extract covariate names into a vector
covariates = setdiff(intersect(colnames(org_df), colnames(X1)[2:ncol(X1)]), c(treatment_variable))
if (is.null(dim(X1[,2:ncol(X1)]))){
if (sd(X1[,2:ncol(X1)])==0){stop("Constant covariate error! \n")}
}
}
}
# if mediation formula is not provided, check whether the mediators argument is meaningful
if (is.null(mediation_formula)){
if (length(mediators) > 0){
# if (is.null(treatment_variable)){
#   stop("Please provide the treatment variable argument!")
# }
for (i.par in 1:length(mediators)){
if (!is.na(suppressWarnings(as.integer(mediators[i.par])))){
mediators[i.par] = colnames(org_df)[as.integer(mediators[i.par])]
}
}
cov_and_med = union(covariates, mediators)
# generate mediation formula
mediation_formula = paste("~(", paste(cov_and_med, collapse="+"), ")*", treatment_variable)
}
}
# extract mediators and check whether it behaves normally
if (!is.null(mediation_formula)){
X1 = tryCatch({model.matrix(formula(mediation_formula), data=df1)},
error = function(e) { return(NA) })
X2 = tryCatch({model.matrix(formula(mediation_formula), data=df2)},
error = function(e) { return(NA) })
if (is.na(X1) || is.na(X2)){ # any of the data fails to be extracted
stop("Mediation input does not work! \n")
}else{# extract covariate names into a vector
mediators = setdiff(intersect(colnames(org_df), colnames(X1)[2:ncol(X1)]),
c(treatment_variable, covariates))
if (is.null(dim(X1[,2:ncol(X1)]))){
if (sd(X1[,2:ncol(X1)])==0){stop("Constant mediator error! \n")}
}
}
}
if (is.null(cluster_id)) {
df1$idformyuse = 1:nrow(df1)
df2$idformyuse = 1:nrow(df2)
cluster_id = "idformyuse"
}
no_covariate_formula = is.null(covariate_formula) || covariate_formula==""
no_mediation_formula = is.null(mediation_formula) || mediation_formula==""
if (no_covariate_formula & no_mediation_formula) {
warning("covariate_formula and mediation_formula cannot both be NULL.")
return()
}
if (is.null(focal_variable)){
focal_variable = treatment_variable
}
# selection variable equals the focal if not specified
if (is.null(selection_variable)){
selection_variable = focal_variable
}
fit = decomposition_helper(
data1 = df1,
data2 = df2,
analysis_formula = analysis_formula,
focal_variable = focal_variable,
covariate_formula = covariate_formula,
mediation_formula = mediation_formula,
cluster_id = cluster_id,
selection_variable = selection_variable
)
data1 = df1
data2 = df2
dim(df1)
dim(df2)
group1 = data1 %>% group_by_at(cluster_id) %>% slice(1)
group2 = data2 %>% group_by_at(cluster_id) %>% slice(1)
dim(grouop1)
dim(group1)
dim(group2)
no_covariate_formula = is.null(covariate_formula) || covariate_formula==""
no_mediation_formula = is.null(mediation_formula) || mediation_formula==""
# Create design matrices.  Care to drop unused factor levels, for the jackknife
if (!no_covariate_formula) {
X1 = model.matrix(formula(covariate_formula), data=group1)[,-1]
X1 = X1[,apply(X1, 2, function(x) { !all(x==0) })]
X2 = model.matrix(formula(covariate_formula), data=group2)[,colnames(X1)]
X = rbind(X1, X2)
}
X1 = model.matrix(formula(covariate_formula), data=group1)[,-1]
head(X1)
colnames(X1)
X1 = X1[,apply(X1, 2, function(x) { !all(x==0) })]
colnames(model.matrix(formula(covariate_formula), data=group2))
covariate_formula
df2
rep.dat
org.dat = read.csv("./host_data_paired/covid_study/original_clean.csv")
org.dat = read.csv("./host_data_paired/covid_study/original_clean.csv")
rep.dat = read.csv("./host_data_paired/covid_study/replication_clean.csv")
view(rep.dat)
covid_result = run_diagnosis(org_df = org.dat,
rep_df = rep.dat,
analysis_formula = "rating ~ treatment + real + realxtreatment",
treatment_variable = "treatment",
focal_variable = "realxtreatment", # focal variable
covariate_formula = "~ (demrep + gender + age + I(age^2) + sciknow + I(sciknow^2) + mms + I(mms^2) + crt_acc + I(crt_acc^2))*treatment",
mediation_formula = NULL,
cluster_id = "id",
selection_variable = "realxtreatment",
alpha = 0.1,
verbose = FALSE,
if_selective = TRUE,
pub_pvalue_threshold = 0.05
)
org_df = org.dat
rep_df = rep.dat
df1 = data.frame(org_df)
df2 = data.frame(rep_df)
fit = decomposition_helper(
data1 = df1,
data2 = df2,
analysis_formula = analysis_formula,
focal_variable = focal_variable,
covariate_formula = covariate_formula,
mediation_formula = mediation_formula,
cluster_id = cluster_id,
selection_variable = selection_variable
)
data1 = df1
data2 = df2
group1 = data1 %>% group_by_at(cluster_id) %>% slice(1)
group2 = data2 %>% group_by_at(cluster_id) %>% slice(1)
no_covariate_formula = is.null(covariate_formula) || covariate_formula==""
no_mediation_formula = is.null(mediation_formula) || mediation_formula==""
# Create design matrices.  Care to drop unused factor levels, for the jackknife
if (!no_covariate_formula) {
X1 = model.matrix(formula(covariate_formula), data=group1)[,-1]
X1 = X1[,apply(X1, 2, function(x) { !all(x==0) })]
X2 = model.matrix(formula(covariate_formula), data=group2)[,colnames(X1)]
X = rbind(X1, X2)
}
if (!no_mediation_formula) {
M1 = model.matrix(formula(mediation_formula), data=group1)[,-1]
M1 = M1[,apply(M1, 2, function(m) { !all(m==0) })]
M2 = model.matrix(formula(mediation_formula), data=group2)[,colnames(M1)]
M = rbind(M1, M2)
}
# Fitting covariate weights
S = c(rep(1, nrow(group1)), rep(0, nrow(group2)))
if (no_covariate_formula) {
group2$w = rep(1, nrow(group2))
} else {
group2$w = ebalance(Treatment=S, X=X, print.level=-1)$w
}
dim(X)
dim(S)
length(S)
dim(X1)
dim(X2)
dim(group1)
X1 = model.matrix(formula(covariate_formula), data=group1)[,-1]
dim(X1)
dim(group1)
head(X1)
sum(is.na(group1))
org.dat = read.csv("./host_data_paired/covid_study/original_clean.csv") %>% mutate_all(~ifelse(is.na(.x), mean(.x, na.rm = TRUE), .x))
sum(is.na(org.dat))
org.dat = read.csv("./host_data_paired/covid_study/original_clean.csv") %>% mutate_all(~ifelse(is.na(.x), mean(.x, na.rm = TRUE), .x))
rep.dat = read.csv("./host_data_paired/covid_study/replication_clean.csv")
covid_result = run_diagnosis(org_df = org.dat,
rep_df = rep.dat,
analysis_formula = "rating ~ treatment + real + realxtreatment",
treatment_variable = "treatment",
focal_variable = "realxtreatment", # focal variable
covariate_formula = "~ (demrep + gender + age + I(age^2) + sciknow + I(sciknow^2) + mms + I(mms^2) + crt_acc + I(crt_acc^2))*treatment",
mediation_formula = NULL,
cluster_id = "id",
selection_variable = "realxtreatment",
alpha = 0.1,
verbose = FALSE,
if_selective = TRUE,
pub_pvalue_threshold = 0.05
)
