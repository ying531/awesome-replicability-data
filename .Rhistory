}else{ # if covariate formula is not provided
if (is.null(covariates)){ # if covariates are also not provided
stop("Please provide covariate formula or covariates! \n")
}else{ # when covariates are present
# turn to names if there are numerical indicators
for (i.par in 1:length(covariates)){
if (!is.na(suppressWarnings(as.integer(covariates[i.par])))){
covariates[i.par] = colnames(org_df)[as.integer(covariates[i.par])]
}
}
covariate_formula = paste("~", paste(covariates, collapse = "+"))
}
# extract covariates and check whether it behaves normally
X1 = tryCatch({model.matrix(formula(covariate_formula), data=org_df)},
error = function(e) { return(NA) })
X2 = tryCatch({model.matrix(formula(covariate_formula), data=rep_df)},
error = function(e) { return(NA) })
if (is.na(X1) || is.na(X2)){ # any of the data fails to be extracted
stop("Covariate input does not work! \n")
}else{# extract covariate names into a vector
covariates = colnames(X1)[2:ncol(X1)]
if (is.null(dim(X1[,2:ncol(X1)]))){
if (sd(X1[,2:ncol(X1)])==0){stop("Constant covariate error! \n")}
}
}
}
#####################################################
######### sanity check for mediator inputs ##########
#####################################################
mediators_all = NULL
if (!is.null(mediation_formula)){
X1 = tryCatch({model.matrix(formula(mediation_formula), data=org_df)},
error = function(e) { return(NA) })
X2 = tryCatch({model.matrix(formula(mediation_formula), data=rep_df)},
error = function(e) { return(NA) })
if (is.na(X1) || is.na(X2)){# any of the data fails to be extracted
cat("Mediation formula incorrect! \n")
stop()
}else{
mediators_all = colnames(X1)[2:ncol(X1)]
}
}else{ # if mediation formula is not provided
if (!is.null(mediators) && length(mediators) > 0){ # if mediators are provided
# turn to names if there are numerical indicators
for (i.par in 1:length(mediators)){
if (!is.na(suppressWarnings(as.integer(mediators[i.par])))){
mediators[i.par] = colnames(org_df)[as.integer(mediators[i.par])]
}
}
# check whether the mediator is constant
if (length(mediators)==1){
if (sd(as.numeric(unlist(org_df[mediators[1]])))==0 || sd(as.numeric(unlist(rep_df[mediators[1]])))==0){
stop("Constant mediator error! \n")
}
}
# generate mediation formula
mediation_formula = paste("~(", paste(covariates, collapse="+"), "+", paste(mediators, collapse = "+"), ")*", treatment_name)
# extract covariates and check whether it behaves normally
X1 = tryCatch({model.matrix(formula(mediation_formula), data=org_df)},
error = function(e) { return(NA) })
X2 = tryCatch({model.matrix(formula(mediation_formula), data=rep_df)},
error = function(e) { return(NA) })
if (is.na(X1) || is.na(X2)){ # any of the data fails to be extracted
stop("Mediator input does not work! \n")
}else{
mediators_all = colnames(X1)[2:ncol(X1)]
}
}
}
####################################################
######### sanity check for cluster inputs ##########
####################################################
clusters_1 = NULL
clusters_2 = NULL
# make sure both ids are present
if ((is.null(id_name_1) && !is.null(id_name_2)) || (is.null(id_name_2) && !is.null(id_name_1))){
stop("Please provide both group IDs!")
}
# if both are provided, generate cluster variables
if (!is.null(id_name_1) && !is.null(id_name_2)){
# generate cluster variables
cluster_1 = c(treatment_name, covariates, mediators_all, id_name_1)
cluster_2 = c(treatment_name, covariates, mediators_all, id_name_2)
}
####################################################
######### decomposition diagnosis ##########
####################################################
org_df = data.frame(org_df)
rep_df = data.frame(rep_df)
results = .decomposition(
data1 = org_df,
data2 = rep_df,
analysis_formula = analysis_formula,
treatment_variable = treatment_name,
covariate_formula = covariate_formula,
mediation_formula = mediation_formula,
clusters_1 = clusters_1,
clusters_2 = clusters_2
)
# choose the cluster id if it is not null
if (!is.null(id_name_1) && !(id_name_1 == '')){
id1 = unique(org_df[,id_name_1])
}else{
id1 = 1:dim(org_df)[1]
}
if (!is.null(id_name_2) && !(id_name_2 == '')){
id2 = unique(rep_df[,id_name_2])
}else{
id2 = 1:dim(rep_df)[1]
}
N1 = length(id1)
N2 = length(id2)
phi1 = phi2 = data.frame()
pb = progress_bar$new("Jackknifing [:bar] :percent", total=N1 + N2, width=80)
total_steps <- N1 + N2
for (i in 1:N1) {
pb$tick()
if (!is.null(id_name_1) && !(id_name_1 == '')){
sub.org_df = filter(org_df, !!sym(id_name_1) != id1[i])
}else{
sub.org_df = org_df[-i,]
}
try({phi1 = bind_rows(phi1, .decomposition(
data1 = sub.org_df,
data2 = rep_df,
analysis_formula = analysis_formula,
treatment_variable = treatment_name,
covariate_formula = covariate_formula,
mediation_formula = mediation_formula,
clusters_1 = clusters_1,
clusters_2 = clusters_2
)$decomp)}, silent = TRUE)
}
for (i in 1:N2) {
pb$tick()
if (!is.null(id_name_2) && !(id_name_2 == '')){
sub.rep_df = rep_df[rep_df[,id_name_2]!=id2[i],]
}else{
sub.rep_df = rep_df[-i,]
}
try({phi2 = bind_rows(phi2, .decomposition(
data1 = org_df,
data2 = sub.rep_df,
analysis_formula = analysis_formula,
treatment_variable = treatment_name,
covariate_formula = covariate_formula,
mediation_formula = mediation_formula,
clusters_1 = clusters_1,
clusters_2 = clusters_2
)$decomp)}, silent = TRUE)
}
phi1 = phi1 %>% drop_na()
phi2 = phi2 %>% drop_na()
if (nrow(phi1) == 0 || nrow(phi2) == 0){
stop("Inference incorrect due to specification errors! \n")
}
SEs = sqrt(apply(phi1, 2, var)*(nrow(phi1)-1)^2/N1 + apply(phi2, 2, var)*(nrow(phi2)-1)^2/N2)
Sigma = var(phi1)*(nrow(phi1)-1)^2/N1 + var(phi2)*(nrow(phi2)-1)^2/N2
# ==================================================
# Plotting results
bounds = cbind(as.numeric(results$decomp),
as.numeric(results$decomp) - qnorm(0.95)*SEs,
as.numeric(results$decomp) + qnorm(0.95)*SEs) %>% data.frame()
pvals = 2 - 2 * pnorm(abs(as.numeric(results$decomp))/SEs)
colnames(bounds) = c("estimate", "low", "high")
bounds$component = rownames(bounds)
if (!is.null(mediation_formula)){
decomp.plot = bounds %>% filter(component != "Original") %>%
mutate(component = factor(component, levels = c("Observed", "Covariates", "Mediators", "Residual"))) %>%
ggplot(aes(x = component, fill = component, y = estimate, ymin = low, ymax = high)) +
geom_crossbar(aes(alpha = 0.8, col = component), width=0.5) +
theme_bw() + xlab("") + ylab("") +
# theme(legend.position = "None") +
geom_hline(yintercept = 0, lty=2)+
theme(text= element_text(family="Times", size=15),
axis.text= element_text(family="Times", size=12),
strip.text.x= element_text(family="Times", size=12),
strip.text.y= element_text(family="Times", size=12),
legend.title = element_text(family="Times", size=15),
legend.position="None",
plot.title = element_text(family="Times", size=15, hjust = 0.5))
ret_table = cbind(as.numeric(results$decomp), SEs, as.numeric(results$decomp)/SEs, pvals)
colnames(ret_table) = c("Estimate", "Std. Error", "t-stat", "Pr(>|z|)")
rownames(ret_table) = c("Original", "Observed", "Covariates", "Mediators", "Residual")
ret_table_df <- as.data.frame(ret_table)
ret_table_df$Component <- rownames(ret_table)
ret_table_df <- ret_table_df[, c("Component", "Estimate", "Std. Error", "t-stat", "Pr(>|z|)")]
if (verbose){ # print summary table
cat("\n")
cat("Summary of decomposition for replication diagnosis:")
cat("\n\n")
print(ret_table)
cat("\n")
print(decomp.plot)
}
# ==============================================================
# Accounting for publication bias at the p = pub_pvalue_threshold level
if (if_selective){
threshold = qnorm(1-pub_pvalue_threshold/2)*summary(lm(analysis_formula, data = org_df))$coefficients[treatment_name, "Std. Error"]
components = c("Observed", "Covariates", "Mediators", "Residual")
bounds = lapply(components, FUN = function(v) {
.selective_ci(
x = results$decomp[c(v, "Original")],
sigma = Sigma[c(v, "Original"), c(v, "Original")],
threshold = threshold,
alpha = alpha
)}) %>% bind_rows()
bounds$component = components
ret_table_sel = data.frame(bounds[,c("low", "high", "estimate")])
rownames(ret_table_sel) = components
# generate error message
sel.message = ""
bounds.sel.tp = data.frame()
for (v in 1:length(components)){
if ((bounds$low[v] == -Inf) || (bounds$high[v] == Inf)){
sel.message = paste(sel.message,
"No meaningful selective CI within [",
bounds$lowest[v], bounds$highest[v],"] for ",
components[v], "component! \n")
}else{
to.add = ret_table_sel[v,]
if ((bounds$estimate[v] == -Inf) || (bounds$estimate[v] < bounds$low[v]) || (bounds$estimate[v] > bounds$high[v])){
to.add$estimate = (to.add$low + to.add$high)/2
}
bounds.sel.tp = rbind(bounds.sel.tp, to.add)
}
}
if (nrow(bounds.sel.tp)>0){
bounds.sel.tp$components = rownames(bounds.sel.tp)
selective.plt = bounds.sel.tp %>%
mutate(component = factor(components, levels = c("Original", "Observed", "Covariates", "Mediators", "Residual"))) %>%
ggplot(aes(x = component, fill = component, y = estimate, ymin = low, ymax = high)) +
geom_crossbar(aes(col = component), alpha = 0.5, width=0.6) +
theme_bw() + xlab("") + ylab("") +
theme(legend.position = "None") +
geom_hline(yintercept = 0, lty=2) +
theme(text= element_text(family="Times", size=15),
axis.text= element_text(family="Times", size=12),
strip.text.x= element_text(family="Times", size=12),
strip.text.y= element_text(family="Times", size=12),
legend.title = element_text(family="Times", size=15),
legend.position="None",
plot.title = element_text(family="Times", size=15, hjust = 0.5))
}else{
selective.plt = NULL
}
}
if (verbose){ # print summary table
cat("\n")
cat("Summary of post-selective decomposition for replication diagnosis:")
cat("\n\n")
print(ret_table_sel)
cat("\n")
if (!is.null(selective.plt)){
print(selective.plt)
}
}
}else{
###### mediation formula is null
decomp.plot = bounds %>% filter(component != "Original") %>%
mutate(component = factor(component, levels = c("Observed", "Covariates", "Residual"))) %>%
ggplot(aes(x = component, fill = component, y = estimate, ymin = low, ymax = high)) +
geom_crossbar(aes(alpha = 0.8, col = component), width=0.5) +
theme_bw() + xlab("") + ylab("") +
geom_hline(yintercept = 0, lty=2)+
theme(text= element_text(family="Times", size=15),
axis.text= element_text(family="Times", size=12),
strip.text.x= element_text(family="Times", size=12),
strip.text.y= element_text(family="Times", size=12),
legend.title = element_text(family="Times", size=15),
legend.position="None",
plot.title = element_text(family="Times", size=15, hjust = 0.5))
ret_table = cbind(as.numeric(results$decomp), SEs, as.numeric(results$decomp)/SEs, pvals)
colnames(ret_table) = c("Estimate", "Std. Error", "t-stat", "Pr(>|z|)")
rownames(ret_table) = c("Original", "Observed", "Covariates", "Residual")
ret_table_df <- as.data.frame(ret_table)
ret_table_df$Component <- rownames(ret_table)
ret_table_df <- ret_table_df[, c("Component", "Estimate", "Std. Error", "t-stat", "Pr(>|z|)")]
if (verbose){ # print summary table
cat("\n")
cat("Summary of decomposition for replication diagnosis:")
cat("\n\n")
print(ret_table)
cat("\n")
print(decomp.plot)
}
# ==============================================================
# Accounting for publication bias at the p = pub_pvalue_threshold level
if (if_selective){
threshold = qnorm(1-pub_pvalue_threshold/2)*summary(lm(analysis_formula, data = org_df))$coefficients[treatment_name, "Std. Error"]
components = c("Observed", "Covariates", "Residual")
bounds = lapply(components, FUN = function(v) {
.selective_ci(
x = results$decomp[c(v, "Original")],
sigma = Sigma[c(v, "Original"), c(v, "Original")],
threshold = threshold,
alpha = alpha
)}) %>% bind_rows()
bounds$component = components
ret_table_sel = data.frame(bounds[,c("low", "high", "estimate")])
rownames(ret_table_sel) = components
# generate error message
sel.message = ""
bounds.sel.tp = data.frame()
for (v in 1:length(components)){
if ((bounds$low[v] == -Inf) || (bounds$high[v] == Inf)){
sel.message = paste(sel.message,
"No meaningful selective CI within [",
bounds$lowest[v], bounds$highest[v],"] for ",
components[v], "component! <br>")
}else{
to.add = ret_table_sel[v,]
if  ((bounds$estimate[v] == -Inf) || (bounds$estimate[v] < bounds$low[v]) || (bounds$estimate[v] > bounds$high[v])){
to.add$estimate = (to.add$low + to.add$high)/2
}
bounds.sel.tp = rbind(bounds.sel.tp, to.add)
}
}
if (nrow(bounds.sel.tp)>0){
bounds.sel.tp$components = rownames(bounds.sel.tp)
selective.plt = bounds.sel.tp %>%
mutate(component = factor(components, levels = c("Original", "Observed", "Covariates", "Mediators", "Residual"))) %>%
ggplot(aes(x = component, fill = component, y = estimate, ymin = low, ymax = high)) +
geom_crossbar(aes(col = component), alpha = 0.8, width=0.5) +
theme_bw() + xlab("") + ylab("") +
theme(legend.position = "None") +
geom_hline(yintercept = 0, lty=2) +
theme(text= element_text(family="Times", size=15),
axis.text= element_text(family="Times", size=12),
strip.text.x= element_text(family="Times", size=12),
strip.text.y= element_text(family="Times", size=12),
legend.title = element_text(family="Times", size=15),
legend.position="None",
plot.title = element_text(family="Times", size=15, hjust = 0.5))
}else{
selective.plt = NULL
}
}
if (verbose){ # print summary table
cat("\n")
cat("Summary of post-selective decomposition for replication diagnosis:")
cat("\n\n")
print(ret_table_sel)
cat("\n")
if (!is.null(selective.plt)){
print(selective.plt)
}
}
}
ret_table_sel$Component <- rownames(ret_table_sel)
ret_table_sel <- ret_table_sel[, c("Component", "low", "high", "estimate")]
colnames(ret_table_sel) = c("Component", "CI.Low", "CI.High", "Estimate")
ret_table_sel$Estimate[ret_table_sel$Estimate==-Inf] = "NULL"
if (nchar(sel.message)>0){
cat(sel.message)
}
return(list("plot" = decomp.plot, "table" = ret_table_df,
"plot_selective" = selective.plt, "table_selective" = ret_table_sel,
"message_selective" = sel.message))
}
.decomposition = function(
data1, # a data frame
data2, # a data frame
analysis_formula, # a formula for OLS
treatment_variable, # the name of the focal variable
covariate_formula = NULL, # covariates to be balanced
mediation_formula = NULL, # covariates + mediators to be balanced
clusters_1 = NULL, # variables defining clusters.  must contain all variables in the covariate/mediation formulae
clusters_2 = NULL
) {
if (is.null(clusters_1)) {
group1 = data1
# group1$id = 1:nrow(group1)
# data1$id = 1:nrow(data1)
} else {
group1 = unique(data1[,clusters_1])
}
if (is.null(clusters_2)) {
group2 = data2
# group2$idx = 1:nrow(group2)
# data2$idx = 1:nrow(data2)
} else {
group2 = unique(data2[,clusters_2])
}
X = model.matrix(formula(covariate_formula), data=bind_rows(group1, group2))[,-1]
S = c(rep(1, nrow(group1)), rep(0, nrow(group2)))
group2$w = ebalance(Treatment=S, X=X, print.level=-1)$w # covariate weights
if (!is.null(mediation_formula)){
M = model.matrix(formula(mediation_formula), data=bind_rows(group1, group2))[,-1]
group2$o = ebalance(Treatment=S, X=M, print.level=-1)$w # mediation weights
}
if (is.null(clusters_2)){
data2weighted = group2
}else{
data2weighted = left_join(data2, group2, by=clusters_2)
}
theta1 = coef(lm(formula(analysis_formula), data=data1))[treatment_variable]
theta2 = coef(lm(formula(analysis_formula), data=data2))[treatment_variable]
theta2X= coef(lm(formula(analysis_formula), data=data2weighted, weights=w))[treatment_variable]
if (!is.null(mediation_formula)){
theta2M= coef(lm(formula(analysis_formula), data=data2weighted, weights=o))[treatment_variable]
decomp = data.frame(
"Original" = theta1,
"Observed" = theta1 - theta2,
"Covariates" = theta2X - theta2,
"Mediators" = theta2M - theta2X,
"Residual" = theta1 - theta2M
)
}else{ # mediation formula is null
decomp = data.frame(
"Original" = theta1,
"Observed" = theta1 - theta2,
"Covariates" = theta2X - theta2,
"Residual" = theta1 - theta2X
)
}
return(list("decomp" = decomp, "w" = group2$w, "o" = group2$o))
}
.selective_t = function(x, delta, sigma, threshold) {
# Tests the null hypothesis mu[1] = delta under X ~ N(mu, Sigma)
# Returns a P-value that remains valid conditional on |x2| > threshold
tau = as.numeric(threshold)
d = as.numeric(delta)
stat = as.numeric(x[1])
sd = as.numeric(sqrt(sigma[1,1]))
beta = as.numeric(sigma[1,2]/sigma[1,1])
R = as.numeric(x[2] - beta*x[1])
low = min((tau-R)/beta, -(tau+R)/beta)
high = max((tau-R)/beta, -(tau+R)/beta)
num = pnorm((min(stat, low) - d)/sd) + pmax(0, pnorm((stat - d)/sd) - pnorm((high - d)/sd))
denom = 1 + pnorm((low - d)/sd) - pnorm((high - d)/sd)
if (denom == 0){
return(Inf)
}else{
return(num/denom)
}
}
.selective_ci = function(x, sigma, threshold, alpha = 0.1) {
# Selective confidence interval for mu[1] conditional on |x[2]| > threshold
lower = as.numeric(x[1] - 20*sqrt(sigma[1,1])) - 10
upper = as.numeric(x[1] + 20*sqrt(sigma[1,1])) + 10
delta.try = seq(lower, upper, by=0.01)
all.val = sapply(delta.try, .selective_t, x=x, sigma=sigma, threshold=threshold)
if (min(abs(all.val-alpha/2)) <= 0.1 * alpha){
low.try = delta.try[which.min(abs(all.val-alpha/2))]
}else{
low.try = -Inf
}
if (min(abs(all.val-0.5)) <= 0.1 * alpha){
med.try = delta.try[which.min(abs(all.val-0.5))]
}else{
med.try = -Inf
}
if (min(abs(all.val-1+alpha/2)) <= 0.1 * alpha){
high.try = delta.try[which.min(abs(all.val-1+alpha/2))]
}else{
high.try = Inf
}
return(data.frame(
"low" = min(low.try, high.try), "high" = max(low.try, high.try), "estimate" = med.try,
"lowest" = lower, "highest" = upper
))
}
run_diagnosis(
org.dat,
rep.dat,
analysis_formula = "rating ~ treatment + real + realxtreatment",
treatment_name = "treatment",
id_name_1 = "id",
id_name_2 = "id",
covariates = c("age", "gender", "hispanic", "social_conserv", "sciknow", "mms"),
mediators = c("discernment")
)
setwd("/Users/ying/Desktop/Stanford/Research/Dominik/decomposition/awesome-replicability-data")
org.dat = read.csv("./time_honest/original_cleaned.csv")
org.dat = read.csv("./host_data_paired/time_honest/original_cleaned.csv")
rep.dat = read.csv("./host_data_paired/time_honest/replication2_cleaned.csv")
head(org.dat)
head(rep.dat)
rep.dat$Gender = 1 * (rep.dat$Gender == 2)
write.csv(rep.dat, "./host_data_paired/time_honest/replication2_cleaned.csv")
run_diagnosis(
org.dat,
rep.dat,
analysis_formula = "Dice_report ~ Treatment",
treatment_name = "Treatment",
covariates = c("gender"),
mediators = c("Report_time")
)
run_diagnosis(
org.dat,
rep.dat,
analysis_formula = "Dice_report ~ Treatment",
treatment_name = "Treatment",
covariates = c("Gender"),
mediators = c("Report_time")
)
org.dat$Dice_report = as.numeric(org.dat$Dice_report)
org.dat$Dice_report
org.dat = read.csv("./host_data_paired/time_honest/original_cleaned.csv")
org.dat$Dice_report
org.dat$Dice_report = as.numeric(org.dat$Dice_report)
org.dat = org.dat %>% drop_na()
run_diagnosis(
org.dat,
rep.dat,
analysis_formula = "Dice_report ~ Treatment",
treatment_name = "Treatment",
covariates = c("Gender"),
mediators = c("Report_time")
)
d
