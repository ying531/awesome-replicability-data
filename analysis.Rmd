---
title: "Analysis"
output: html_document
date: '2023-04-22'
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(ebal)
library(progress)
library(ggplot2)
library(lmtest)
library(sandwich)
library(repDiagnosis)
library(ggpubr)
library(ggtext)
```

```{r, echo=FALSE}
run_diagnosis <- function(
    org_df,
    rep_df,
    analysis_formula,
    treatment_variable, # column name for the treatment indicator (1 = treatment)
    focal_variable = NULL, # focal variable
    covariates = NULL,
    covariate_formula = NULL,
    mediators = NULL,
    mediation_formula = NULL,
    cluster_id = NULL,
    selection_variable = NULL,
    alpha = 0.1,
    verbose = TRUE,
    if_selective = TRUE,
    pub_pvalue_threshold = 0.05
){

  df1 = data.frame(org_df)
  df2 = data.frame(rep_df)



  #####################################################
  ######### sanity check for covariate inputs #########
  #####################################################

  # if covariate formula is not provided, check whether the covariates argument is meaningful
  # otherwise just use the covariate formula
  if (is.null(covariate_formula)){
    if (length(covariates) > 0){
      for (i.par in 1:length(covariates)){
        if (!is.na(suppressWarnings(as.integer(covariates[i.par])))){
          covariates[i.par] = colnames(org_df)[as.integer(covariates[i.par])]
        }
      }
      # if (is.null(treatment_variable)){
      #   stop("Please provide the treatment variable argument!")
      # }
      covariate_formula = paste("~(", paste(covariates, collapse = "+"), ") *", treatment_variable)
    }
  }

  # extract covariates and check whether it behaves normally
  if (!is.null(covariate_formula)){
    X1 = tryCatch({model.matrix(formula(covariate_formula), data=org_df)},
                  error = function(e) { return(NA) })
    X2 = tryCatch({model.matrix(formula(covariate_formula), data=rep_df)},
                  error = function(e) { return(NA) })
    if (is.na(X1) || is.na(X2)){ # any of the data fails to be extracted
      stop("Covariate input does not work! \n")
    }else{# extract covariate names into a vector
      covariates = setdiff(intersect(colnames(org_df), colnames(X1)[2:ncol(X1)]), c(treatment_variable))
      if (is.null(dim(X1[,2:ncol(X1)]))){
        if (sd(X1[,2:ncol(X1)])==0){stop("Constant covariate error! \n")}
      }
    }
  }

  #####################################################
  ######### sanity check for mediation inputs #########
  #####################################################

  # if mediation formula is not provided, check whether the mediators argument is meaningful
  if (is.null(mediation_formula)){
    if (length(mediators) > 0){
      # if (is.null(treatment_variable)){
      #   stop("Please provide the treatment variable argument!")
      # }

      for (i.par in 1:length(mediators)){
        if (!is.na(suppressWarnings(as.integer(mediators[i.par])))){
          mediators[i.par] = colnames(org_df)[as.integer(mediators[i.par])]
        }
      }

      cov_and_med = union(covariates, mediators)
      # generate mediation formula
      mediation_formula = paste("~(", paste(cov_and_med, collapse="+"), ")*", treatment_variable)

    }
  }

  # extract mediators and check whether it behaves normally
  if (!is.null(mediation_formula)){
    X1 = tryCatch({model.matrix(formula(mediation_formula), data=df1)},
                  error = function(e) { return(NA) })
    X2 = tryCatch({model.matrix(formula(mediation_formula), data=df2)},
                  error = function(e) { return(NA) })
    if (is.na(X1) || is.na(X2)){ # any of the data fails to be extracted
      stop("Mediation input does not work! \n")
    }else{# extract covariate names into a vector
      mediators = setdiff(intersect(colnames(org_df), colnames(X1)[2:ncol(X1)]),
                          c(treatment_variable, covariates))
      if (is.null(dim(X1[,2:ncol(X1)]))){
        if (sd(X1[,2:ncol(X1)])==0){stop("Constant mediator error! \n")}
      }
    }
  }

  #####################################################
  ######### sanity check for other inputs #########
  #####################################################

  if (is.null(cluster_id)) {
    df1$idformyuse = 1:nrow(df1)
    df2$idformyuse = 1:nrow(df2)
    cluster_id = "idformyuse"
  }

  no_covariate_formula = is.null(covariate_formula) || covariate_formula==""
  no_mediation_formula = is.null(mediation_formula) || mediation_formula==""

  if (no_covariate_formula & no_mediation_formula) {
    warning("covariate_formula and mediation_formula cannot both be NULL.")
    return()
  }

  if (is.null(focal_variable)){
    focal_variable = treatment_variable
  }

  # selection variable equals the focal if not specified
  if (is.null(selection_variable)){
    selection_variable = focal_variable
  }

  fit = decomposition_helper(
    data1 = df1,
    data2 = df2,
    analysis_formula = analysis_formula,
    focal_variable = focal_variable,
    covariate_formula = covariate_formula,
    mediation_formula = mediation_formula,
    cluster_id = cluster_id,
    selection_variable = selection_variable
  )

  results = fit$decomp
  clusters1 = unique(df1[[cluster_id]])
  clusters2 = unique(df2[[cluster_id]])


  N1 = length(clusters1)
  N2 = length(clusters2)
  phi1 = phi2 = data.frame()
  pb = progress_bar$new("Jackknifing [:bar] :percent", width=80, total=N1 + N2+1)

  # Add progress bar
  total_steps = N1+N2 + 1


  for (i in 1:N1) {
    if (verbose) { pb$tick() }

    tryCatch({phi1 = bind_rows(phi1, decomposition_helper(
      data1 = df1[df1[[cluster_id]] != clusters1[i],],
      data2 = df2,
      analysis_formula = analysis_formula,
      focal_variable = focal_variable,
      covariate_formula = covariate_formula,
      mediation_formula = mediation_formula,
      cluster_id = cluster_id,
      selection_variable = selection_variable
    )$decomp)}, error = function(e) {})
  }
  for (i in 1:N2) {
    if (verbose) { pb$tick() }

    tryCatch({phi2 = bind_rows(phi2, decomposition_helper(
      data1 = df1,
      data2 = df2[df2[[cluster_id]] != clusters2[i],],
      analysis_formula = analysis_formula,
      focal_variable = focal_variable,
      covariate_formula = covariate_formula,
      mediation_formula = mediation_formula,
      cluster_id = cluster_id,
      selection_variable = selection_variable
    )$decomp)}, error = function(e) {})
  }

  SEs = sqrt(apply(phi1, 2, var)*(nrow(phi1)-1)^2/N1 + apply(phi2, 2, var)*(nrow(phi2)-1)^2/N2)
  Sigma = var(phi1)*(nrow(phi1)-1)^2/N1 + var(phi2)*(nrow(phi2)-1)^2/N2

  # ==================================================
  # Plotting results

  # non-selective results
  pvals = 2 - 2 * pnorm(abs(as.numeric(fit$decomp))/SEs)
  ret_table = cbind(as.numeric(fit$decomp), SEs, as.numeric(fit$decomp)/SEs, pvals)
  colnames(ret_table) = c("Estimate", "Std. Error", "t-stat", "Pr(>|z|)")
  ret_table = ret_table[rownames(ret_table) != "Selected",]
  rownames(ret_table)[1] = "Observed discrepancy"
  ret_table_df <- as.data.frame(ret_table)
  ret_table_df$Component <- rownames(ret_table)
  ret_table_df <- ret_table_df[, c("Component", "Estimate", "Std. Error", "t-stat", "Pr(>|z|)")]

  clean_decomp = select(fit$decomp, -Selected)
  clean_SE = SEs[2:length(SEs)]
  clean_low = clean_decomp
  clean_low[2:length(clean_low)] = clean_low[2:length(clean_low)] - qnorm(1-alpha/2) * clean_SE[2:length(clean_SE)]
  clean_high = clean_decomp
  clean_high[2:length(clean_high)] = clean_high[2:length(clean_high)] + qnorm(1-alpha/2) * clean_SE[2:length(clean_SE)]

  component = c("Observed discrepancy")
  if (!no_covariate_formula){
    component = c(component, "+ Covariate shift")
  }
  if (!no_mediation_formula){
    component = c(component, "+ Mediation shift")
  }
  component = c(component, "+ Residual", "= Sampling variability")
  bounds_for_plot = data.frame("low" = c(as.numeric(clean_low),
                                         -qnorm(1-alpha/2) * (as.numeric(clean_SE[1]))),
                               "high" = c(as.numeric(clean_high),
                                          qnorm(1-alpha/2) * (as.numeric(clean_SE[1]))),
                               "estimate" = c(as.numeric(clean_decomp),0),
                               "component" = component)
  suppressWarnings({
    decomp.plot = discrepancy_plot(bounds_for_plot, alpha=0.1, base_size=28, digital=2)
  })

  # selective part
  decomp.plot.sel = NULL
  sel.message = NULL
  ret_table_sel_df = NULL
  if (if_selective){
    sel.message = "NOTE:"

    if ((as.numeric(pvals['Selected']) > pub_pvalue_threshold)){
      sel.message = paste(sel.message,
                          "Original p-value > publication bias threshold, stop running selective inference! \n")
      pb$tick()
      return(list("plot" = decomp.plot, "table" = ret_table_df,
                  "sel.plot" = NULL, "sel.table" = NULL,
                  "sel.message" = sel.message))
    }else{
      sel.message = paste(sel.message,
                          paste("Running selective inference conditional on p <= ", pub_pvalue_threshold,"! \n",sep=''))
      bounds_sel = selective_decomposition(fit$decomp, Sigma,
                                           qnorm(1-pub_pvalue_threshold/2) * sqrt(Sigma["Selected", "Selected"]),
                                           alpha=alpha)
    }


    # generate table
    ret_table_sel = bounds_sel[1:(nrow(bounds_sel)-1),]
    rownames(ret_table_sel) = ret_table_sel$component
    rownames(ret_table_sel)[2:nrow(ret_table_sel)] = sapply(rownames(ret_table_sel)[2:nrow(ret_table_sel)],
                                                            function(x) substr(x, 3, nchar(x)))
    ret_table_sel_df = data.frame(ret_table_sel)

    # selective table
    ret_table_sel_df$Component <- rownames(ret_table_sel_df)
    ret_table_sel_df <- ret_table_sel_df[, c("Component", "low", "high", "estimate")]
    colnames(ret_table_sel_df) = c("Component", "CI.Low", "CI.High", "Estimate")
    ret_table_sel_df$Estimate = as.numeric(ret_table_sel_df$Estimate)

    ret_table_sel_df$Estimate[ret_table_sel_df$Estimate==-Inf] = NULL
    ret_table_sel_df$Estimate[ret_table_sel_df$Estimate==Inf] = NULL

    # generate error message
    components = rownames(ret_table_sel_df)

    for (v in 1:length(components)){

      if ((ret_table_sel_df$CI.Low[v] == -Inf) || (ret_table_sel_df$CI.High[v] == Inf)){
        sel.message = paste(sel.message,
                            "No meaningful selective CI within est +- 256*se for ",
                            components[v], "component! \n")
      }

    }


    # generate selective decomposition plot
    bounds_for_plot_sel = data.frame(bounds_sel) %>% drop_na()
    if (nrow(bounds_for_plot_sel) >0 ){
      if (("Observed discrepancy" %in% bounds_for_plot_sel$component)){
        bounds_for_plot_sel$low[1] = bounds_for_plot_sel$estimate[1]
        bounds_for_plot_sel$high[1] = bounds_for_plot_sel$estimate[1]
      }
      suppressWarnings({
      decomp.plot.sel = discrepancy_plot(bounds_for_plot_sel, alpha=alpha, base_size=28, digital=2)
      })

    }else{
      decomp.plot.sel = NULL
    }
  }

  if (verbose){
    cat("\n")
    cat("\n")
    cat("Message for selective inferece:\n")
    cat(sel.message)
  }


  pb$tick()

  ret_table_df = select(ret_table_df, -Component) 
  ret_table_df = ret_table_df %>% mutate_if(is.numeric, function(x) round(x,4))
  
  if (if_selective){
    ret_table_sel_df = select(ret_table_sel_df, -Component)
    ret_table_sel_df = ret_table_sel_df %>% mutate_if(is.numeric, function(x) round(x,4))
  }

  return(list("plot" = decomp.plot, "table" = ret_table_df,
              "sel.plot" = decomp.plot.sel, "sel.table" = ret_table_sel_df,
              "sel.message" = sel.message))

}


decomposition_helper = function(
    data1, # original data
    data2, # replication data
    analysis_formula, # a formula for OLS
    focal_variable, # the name of the focal variable
    covariate_formula = NULL, # covariates to be balanced
    mediation_formula = NULL, # covariates + mediators to be balanced
    cluster_id, # variable to cluster on. well-defined before calling this function
    selection_variable = NULL # variable on which the selection happens
) {


  group1 = data1 %>% group_by_at(cluster_id) %>% slice(1)
  group2 = data2 %>% group_by_at(cluster_id) %>% slice(1)

  no_covariate_formula = is.null(covariate_formula) || covariate_formula==""
  no_mediation_formula = is.null(mediation_formula) || mediation_formula==""


  # Create design matrices.  Care to drop unused factor levels, for the jackknife
  if (!no_covariate_formula) {
    X1 = model.matrix(formula(covariate_formula), data=group1)[,-1]
    X1 = X1[,apply(X1, 2, function(x) { !all(x==0) })]
    X2 = model.matrix(formula(covariate_formula), data=group2)[,colnames(X1)]
    X = rbind(X1, X2)
  }
  if (!no_mediation_formula) {
    M1 = model.matrix(formula(mediation_formula), data=group1)[,-1]
    M1 = M1[,apply(M1, 2, function(m) { !all(m==0) })]
    M2 = model.matrix(formula(mediation_formula), data=group2)[,colnames(M1)]
    M = rbind(M1, M2)
  }

  # Fitting covariate weights
  S = c(rep(1, nrow(group1)), rep(0, nrow(group2)))
  if (no_covariate_formula) {
    group2$w = rep(1, nrow(group2))
  } else {
    group2$w = ebalance(Treatment=S, X=X, print.level=-1)$w
  }

  # Fitting mediation weights
  if (no_mediation_formula) {
    group2$o = group2$w
  } else {
    group2$o = ebalance(Treatment=S, X=M, print.level=-1)$w
  } 
  data2_joined = left_join(data2, group2[,c(cluster_id, "w", "o")], by = c(cluster_id)) 

  # Re-performing analysis
  selection = coef(lm(formula(analysis_formula), data=data1))[selection_variable]
  theta1 = coef(lm(formula(analysis_formula), data=data1))[focal_variable]
  theta2 = coef(lm(formula(analysis_formula), data=data2_joined))[focal_variable] 
  theta2X= coef(lm(formula(analysis_formula), data=data2_joined, weights=data2_joined$w))[focal_variable] 
  theta2M= coef(lm(formula(analysis_formula), data=data2_joined, weights=data2_joined$o))[focal_variable] 

  # Computing decomposition
  decomp = data.frame(
    "Selected" = selection,
    "Observed" = theta1 - theta2,
    "Covariates" = theta2X - theta2,
    "Mediators" = theta2M - theta2X,
    "Residual" = theta1 - theta2M
  )
  if (no_covariate_formula) {
    decomp = select(decomp, -Covariates)
  }
  if (no_mediation_formula) {
    decomp = select(decomp, -Mediators)
  }

  return(list("decomp" = decomp, "w" = group2$w, "o" = group2$o))

}




selective_decomposition = function(decomp, Sigma, threshold, alpha=0.1) {
  # Selective confidence intervals and conditional MLEs
  x = decomp#$decomp
  S = Sigma#$Sigma
  observed = x[["Observed"]]

  # Compute selection-adjusted confidence intervals for each component
  components = setdiff(names(x), "Selected")
  bounds = lapply(
    X = components,
    FUN = function(v) { vars = c(v, "Selected"); selective_ci(x[vars], S[vars, vars], threshold, alpha)}
  ) %>% bind_rows()
  rownames(bounds) = components

  # Compute selection-adjusted point estimates for the non-residual components 
  vars = setdiff(components[which(bounds$low != -Inf)], "Residual") 
  SX = S[vars, vars]
  SXY = S[vars, "Selected"]
  Omega = solve(SX)
  beta = as.numeric(Omega %*% SXY)
  sigma = as.numeric(sqrt(t(beta) %*% SX %*% beta))
  R = as.numeric(x["Selected"] - sum(beta*x[vars]))
  
  suppressWarnings({
    estimate = optim(
      par = as.numeric(unlist((bounds["high"] - bounds["low"])/2))[setdiff(which(bounds$low!=-Inf), length(components))], # Midpoint initialization
      fn = function(par) {
        0.5*t(as.numeric(x[vars]-par)) %*% Omega %*% as.numeric(x[vars]-par) +
          truncprob(mean = sum(par*beta), sd = sigma, R = R, threshold = threshold, log.prob = T)
      }
    )$par # Maximum conditional likelihood
  })
  
  if (length(estimate >1)){
    names(estimate) = vars
  }else{
    estimate = c(estimate,0)
    names(estimate) = c(vars, "placeholder")
  }
  names(estimate) = vars
  bounds$estimate = as.numeric(decomp[components]) 
  
  bounds$estimate[which(bounds$low!=-Inf)] = sapply(
    X = components[which(bounds$low!=-Inf)],
    FUN = function(comp) {
      if (comp == "Observed") {
        return(observed)
      } else if (comp == "Residual") {
        return(as.numeric(2*estimate["Observed"] - sum(estimate)))
      } else {
        return(estimate[[comp]])
      }
    }
  )

  # Compute the estimate of sampling variability
  if (bounds$low[1] != -Inf){
      bounds = rbind(bounds, observed - c(bounds["Observed", "high"], bounds["Observed", "low"], estimate["Observed"]))
  }else{
    bounds = rbind(bounds, observed - c(bounds["Observed", "high"], bounds["Observed", "low"], 0))
  }
  

  # Return results
  bounds$component0 = c(components, "Sampling")
  clean_names = data.frame(
    component0 = c("Observed", "Covariates", "Mediators", "Residual", "Sampling"),
    component = c("Observed discrepancy", "+ Covariate shift", "+ Mediation shift", "+ Residual", "= Sampling variability")
  )
  bounds = left_join(data.frame(bounds), clean_names, by = c("component0")) %>% select(-component0)
  
  bounds$low[is.na(bounds$low)] = -Inf
  bounds$high[is.na(bounds$high)] = Inf
  return(bounds)
}


discrepancy_plot = function(bounds, alpha=0.1, base_size=28, digital=2) {
  # Bounds should be a data frame of the type returned by "selective_decomposition"
  df_plot = bounds %>% mutate(
    level = factor(component, levels=c("+ Residual", "+ Mediation shift", "+ Covariate shift", "= Sampling variability", "Observed discrepancy"))
  )
  # Location of the numbers and line
  xnums = min(df_plot$low) - 0.2*(max(df_plot$high) - min(df_plot$low))
  xline = min(df_plot$low) - 0.6*(max(df_plot$high) - min(df_plot$low)) - 0.008*(digital-2)
  balance_sheet_plot = df_plot %>% ggplot() +
    geom_crossbar(aes(y = level, x = estimate, col = level, fill = level,
                      xmin = low, xmax = high),
                  width = 0.5, alpha = 0.5) +
    geom_text(aes(x = xnums, y = level, label=paste(ifelse(estimate>=0, "+", ""),
                                                    as.character(round(estimate, digital)), sep="")),
              hjust = 1, size = base_size*0.27) +
    geom_vline(xintercept = 0, lty = 2) +
    geom_vline(xintercept = df_plot$estimate[1], lty=2) +
    ylab("") +
    xlab("") +
    theme_bw(base_size = base_size) +
    theme(
      legend.position = "None",
      panel.grid.major = element_blank(),
      panel.grid.minor = element_blank(),
      panel.border = element_blank(),
      axis.ticks = element_blank(),
      axis.text.y = element_text(face = c(rep("italic", 4), "bold")),
      axis.text.x = element_text(size=base_size*0.5),
      plot.margin = unit(c(0.7, 0.7, -0.5, -0.5), "cm")
    ) +
    annotate(geom = "segment", x = xline, xend = xline, y = -Inf, yend = Inf) +
    scale_x_continuous(breaks = c(0, round(df_plot$estimate[1], 2)))
  return(balance_sheet_plot)
}


truncprob = function(mean, sd, R, threshold, log.prob=TRUE) {
  # Probability that |N(mean, sd) + R| > threshold > 0
  upper = 1-pnorm((threshold-R-mean)/sd) # P{N(mu, sigma^2) > threshold - R}
  lower = pnorm(-(threshold+R+mean)/sd) # P{N(mu, sigma^2) < -threshold - R}
  return(ifelse(log.prob, log(upper+lower), upper+lower))
}

selective_pval = function(mu, x, Sigma, threshold) {
  x = as.numeric(x)
  threshold = as.numeric(threshold)
  beta = as.numeric(Sigma[1,2]/Sigma[1,1])
  s1 = as.numeric(sqrt(Sigma[1,1]))
  R = as.numeric(x[2] - beta*x[1])
  if (beta >= 0) {
    num =
      pnorm((pmin(-(threshold+R)/beta, x[1]) - mu)/s1) +
      pmax(0, pnorm((x[1]-mu)/s1) - pnorm(((threshold-R)/beta - mu)/s1))
    denom =
      pnorm((-(threshold+R)/beta - mu)/s1) + pnorm(((threshold-R)/beta - mu)/s1, lower.tail=F)
    if (denom==0){return(1)}else{return(num/denom)}
    # return(num/denom)
  } else {
    num =
      pnorm((pmin((threshold-R)/beta, x[1]) - mu)/s1) +
      pmax(0, pnorm((x[1]-mu)/s1) - pnorm((-(threshold+R)/beta - mu)/s1))
    denom =
      pnorm(((threshold-R)/beta - mu)/s1) + pnorm((-(threshold+R)/beta - mu)/s1, lower.tail=F)
    if (denom==0){return(1)}else{return(num/denom)}
  }
}

selective_ci = function(xx, SSigma, threshold, alpha = 0.1) {
  # Confidence interval for mu[1], valid conditional on |x[2]| > threshold
  base.factor = 10
  low = tryCatch({
   uniroot(
    f = function(mu) { selective_pval(mu, xx, SSigma, threshold) - alpha/2 },
    lower = as.numeric(xx[1] - 10*sqrt(SSigma[1,1])),
    upper = as.numeric(xx[1] + 10*sqrt(SSigma[1,1]))
  )$root
  }, error = function(e) {NA}
  )
  while (is.na(low) & base.factor < 2^8){
    base.factor = base.factor * 2
    low = tryCatch({
     uniroot(
      f = function(mu) { selective_pval(mu, xx, SSigma, threshold) - alpha/2 },
      lower = as.numeric(xx[1] - base.factor*sqrt(SSigma[1,1])),
      upper = as.numeric(xx[1] + base.factor*sqrt(SSigma[1,1]))
    )$root
    }, error = function(e) {NA}
    )
  }
  base.factor = 10
  high = tryCatch({
    uniroot(
      f = function(mu) { selective_pval(mu, xx, SSigma, threshold) - (1-alpha/2) },
      lower = as.numeric(xx[1] - 10*sqrt(SSigma[1,1])),
      upper = as.numeric(xx[1] + 10*sqrt(SSigma[1,1]))
    )$root
  }, error = function(e) {NA}
  )
  while (is.na(high) & base.factor < 2^8){
    base.factor = base.factor * 2
    high = tryCatch({
    uniroot(
      f = function(mu) { selective_pval(mu, xx, SSigma, threshold) - (1-alpha/2) },
      lower = as.numeric(xx[1] - 10*sqrt(SSigma[1,1])),
      upper = as.numeric(xx[1] + 10*sqrt(SSigma[1,1]))
    )$root
  }, error = function(e) {NA}
  )
  }
  if (!is.na(low) & !is.na(high)){
    return(data.frame("low" = min(low, high), "high" = max(low, high)))
  }else{
    return(data.frame("low"=-Inf, "high"=Inf))
  }
  
}


```

## 1. EMDR and misinformation


```{r, echo = TRUE, fig.width=10, fig.height=4}
data(emdr_misinfo) 

emdr_results = run_diagnosis(org_df = org.dat, 
               rep_df = rep.dat,
               analysis_formula = "totalcorrect ~ condition", 
               treatment_variable = "condition",
               covariate_formula = "~ age + gender + prevividness + preemotionality",
               mediation_formula = "~  (age + gender + prevividness + preemotionality + postvividness + postemotionality)*condition",
               verbose = FALSE)

# Decomposition plot 
emdr_results$plot  
# Decomposition plot after adjusting for publication bias
emdr_results$sel.plot 


# Decomposition summary table
print(emdr_results$table)
# Decomposition summary table after adjusting for publication bias
print(emdr_results$sel.table)
```



## 2. Cleanliness and moral judgement 


### 2.1 Experiment 1

```{r, echo = TRUE, fig.width=10, fig.height=4}
data(clean_moral_1)

clean_results_1 = run_diagnosis(org.dat, 
                                rep.dat, 
                                analysis_formula = "vignettes ~ condition",
                                treatment_variable = "condition", 
                                covariates = c("age", "gender"),
                                mediators = c("disgusted"), 
                                verbose = FALSE,
                                pub_pvalue_threshold = 0.1
                                )

# Decomposition plot 
clean_results_1$plot
# Decomposition plot after adjusting for publication bias
clean_results_1$sel.plot 


# Decomposition summary table 
print(clean_results_1$table)
# Decomposition summary table after adjusting for publication bias
print(clean_results_1$sel.table)
```


### 2.2 Experiment 2

```{r, echo = TRUE}
data(clean_moral_2, fig.width=10, fig.height=4)
rep.dat = rep.dat %>% drop_na()

clean_results_2 = run_diagnosis(org.dat, rep.dat, 
                                analysis_formula = "vignette ~ condition",
                                treatment_variable = "condition", 
                                covariates = c("age", "gender"),
                                mediators = c("disgusted"), 
                                verbose = FALSE
                                )

# Decomposition plot
clean_results_2$plot 
# Decomposition plot after adjusting for publication bias
clean_results_2$sel.plot 
 

# Decomposition summary table
clean_results_2$table
# Decomposition summary table after adjusting for publication bias 
clean_results_2$sel.table
```


## 3. Covid misinformation 

### 3.1. Interaction effect

```{r, eval=TRUE, fig.width=10, fig.height=3}
org.dat = read.csv("./host_data_paired/covid_study/original_clean.csv") %>% mutate_all(~ifelse(is.na(.x), mean(.x, na.rm = TRUE), .x)) 
rep.dat = read.csv("./host_data_paired/covid_study/replication_clean.csv") 

covid_result = run_diagnosis(org_df = org.dat,
                             rep_df = rep.dat, 
                             analysis_formula = "rating ~ treatment + real + realxtreatment",
                             treatment_variable = "treatment", 
                             focal_variable = "realxtreatment", # focal variable 
                             covariate_formula = "~ (demrep + gender + age + I(age^2) + sciknow + I(sciknow^2) + mms + I(mms^2) + crt_acc + I(crt_acc^2))*treatment",
                             mediation_formula = NULL,
                             cluster_id = "id",
                             selection_variable = "realxtreatment",
                             alpha = 0.1,
                             verbose = FALSE,
                             if_selective = TRUE,
                             pub_pvalue_threshold = 0.05
                             )

# Decomposition plot
covid_result$plot 
# Decomposition plot after adjusting for publication bias
covid_result$sel.plot 
 

# Decomposition summary table
covid_result$table
# Decomposition summary table after adjusting for publication bias 
covid_result$sel.table
```


### 3.2. Main effect


```{r, echo = TRUE, fig.width=10, fig.height=3}
org.dat = read.csv("./host_data_paired/covid_study/original_clean.csv") %>% mutate_all(~ifelse(is.na(.x), mean(.x, na.rm = TRUE), .x))
rep.dat = read.csv("./host_data_paired/covid_study/replication_clean.csv") 
  
covid_main_result = run_diagnosis(org_df = org.dat,
                             rep_df = rep.dat, 
                             analysis_formula = "rating ~ treatment + real + realxtreatment",
                             treatment_variable = "treatment", 
                             focal_variable = "treatment", # focal variable 
                             covariate_formula = "~ (demrep + gender + age + I(age^2) + sciknow + I(sciknow^2) + mms + I(mms^2) + crt_acc + I(crt_acc^2))*treatment",
                             mediation_formula = NULL,
                             cluster_id = "id",
                             selection_variable = "realxtreatment",
                             alpha = 0.1,
                             verbose = FALSE,
                             if_selective = TRUE,
                             pub_pvalue_threshold = 0.05
                             )

# Decomposition plot
covid_main_result$plot 
# Decomposition plot after adjusting for publication bias
covid_main_result$sel.plot 
 

# Decomposition summary table
covid_main_result$table
# Decomposition summary table after adjusting for publication bias 
covid_main_result$sel.table
 
```

## 4. Time and honestness

```{r, echo=TRUE, fig.width=10, fig.height=4}
org.dat = read.csv("./host_data_paired/time_honest/original_cleaned.csv")
rep.dat = read.csv("./host_data_paired/time_honest/replication2_cleaned.csv")

org.dat$Dice_report = as.numeric(org.dat$Dice_report)
org.dat = org.dat %>% drop_na()

honest_result = run_diagnosis(org.dat, rep.dat, 
                              analysis_formula = "Dice_report ~ Treatment",
                              treatment_variable = "Treatment",  
                              covariates = c("Gender"), 
                              mediators = c("Report_time"),
                              verbose = FALSE)

# Decomposition plot
honest_result$plot 
# Decomposition plot after adjusting for publication bias
honest_result$sel.plot 
 

# Decomposition summary table
honest_result$table
# Decomposition summary table after adjusting for publication bias 
honest_result$sel.table
 
```

## 5. Empathy and SES

```{r, echo=TRUE, fig.width=10, fig.height=4}
org.dat = read.csv("./host_data_paired/empathy_ses/replication_study1_cleaned.csv") %>% drop_na(c("Age", "Gender_Coded", "Born_US", "Ethnicity_Coded", "Religiousity", "Political_Aff",
                 "Income", "E_Compassion", "E_Sympathy"))
org.dat$Born_US = 1 * org.dat$Born_US
rep.dat = read.csv("./host_data_paired/empathy_ses/replication_study2_cleaned.csv") %>% drop_na(c("Age", "Gender_Coded", "Born_US", "Ethnicity_Coded", "Religiousity", "Political_Aff",
                 "Income", "E_Compassion", "E_Sympathy"))
rep.dat$Born_US = 1 * rep.dat$Born_US

empathy_result = run_diagnosis(
  org_df = org.dat, 
  rep_df = rep.dat, 
  analysis_formula = "Decision_DV ~ Treatment",
  treatment_variable = "Treatment",   
  covariates = c("Age", "Gender_Coded", "Born_US", "Ethnicity_Coded", "Religiousity", "Political_Aff", "Income"), 
  mediators = c("E_Compassion", "E_Sympathy"), 
  verbose = FALSE
)

# Decomposition plot
empathy_result$plot 
# Decomposition plot after adjusting for publication bias
empathy_result$sel.plot
 

# Decomposition summary table
empathy_result$table
# Decomposition summary table after adjusting for publication bias 
empathy_result$sel.table 
```


## 6. Pain and cooperation 

```{r, echo=TRUE, fig.width=10, fig.height=4}
org.dat = read.csv("./host_data_paired/pain_coop/original_clean.csv") %>% select(-c(subid))
rep.dat = read.csv("./host_data_paired/pain_coop/replication1_clean.csv") %>% select(-c(subid))

org.dat = org.dat %>% drop_na(c("subage", "subgender", "feel_interested", "feel_active", "task_challenging"))
rep.dat = rep.dat %>% drop_na(c("subage", "subgender", "feel_interested", "feel_active", "task_challenging"))

coop_result = run_diagnosis(org.dat, rep.dat, 
                            analysis_formula = "cooperation ~ condition",
                            treatment_variable = "condition", 
                            cluster_id = "groupnr",  
                            covariates = c("subage", "subgender"), 
                            mediators = c("feel_interested", "feel_active", "task_challenging"),
                            verbose = FALSE,
                            pub_pvalue_threshold = 0.1)
cat(coop_result$sel.message)

# Decomposition plot
coop_result$plot 
# Decomposition plot after adjusting for publication bias
coop_result$sel.plot 
 

# Decomposition summary table
coop_result$table
# Decomposition summary table after adjusting for publication bias 
coop_result$sel.table

```

## 7. Queueing design

```{r, echo=TRUE, fig.width=10, fig.height=3}
org.dat = read.csv("./host_data_paired/queue/original_clean.csv") 
rep.dat = read.csv("./host_data_paired/queue/replication_clean.csv") 

org.dat$gender = 1 * (org.dat$gender == "Male")
rep.dat$gender = 1 * (rep.dat$gender == "Male")
rep.dat$structure = 1 * (rep.dat$structure == "Single")
org.dat$structure = 1 * (org.dat$structure == 'Single')
org.dat$managerial = 1 * (org.dat$managerial == "Yes")
rep.dat$managerial = 1 * (rep.dat$managerial == "Yes")

org.dat.lab = org.dat %>% filter(study == "lab")
org.dat.mturk = org.dat %>% filter(study == 'mturk')
rep.dat.uwm = rep.dat %>% filter(study == "UWMadison")
rep.dat.usc = rep.dat %>% filter(study == "USC")

queue_result = run_diagnosis(org.dat.lab, 
                             rep.dat.uwm, 
                             analysis_formula = "median_speed ~ structure + gender + bornafter1990 + managerial",
                             treatment_variable = "structure", 
                             covariates = c("gender", "bornafter1990", "managerial"),  
                             verbose = FALSE,
                             pub_pvalue_threshold = 0.1)

cat(queue_result$sel.message)

# Decomposition plot
queue_result$plot  

# Decomposition summary table
queue_result$table
# Decomposition summary table after adjusting for publication bias 
queue_result$sel.table
 
```



```{r, echo=FALSE}
save(emdr_results, clean_results_1, clean_results_2, covid_result, honest_result, empathy_result, coop_result, queue_result, file = "analysis_results.RData")
```
